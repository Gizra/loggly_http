<?php

/**
 * @file
 * Logs HTTP module.
 */

use Drupal\Component\Serialization\Json;
use Drupal\Component\Utility\Crypt;
use Drupal\Core\Logger\RfcLogLevel;
use Drupal\Core\Utility\Error;

/**
 * Provides custom PHP exception handling.
 *
 * Uncaught exceptions are those not enclosed in a try/catch block. They are
 * always fatal: the execution of the script will stop as soon as the exception
 * handler exits.
 *
 * @param $exception
 *   The exception object that was thrown.
 *
 * @see _drupal_exception_handler()
 */
function _logs_http_exception_handler($exception) {
  require_once DRUPAL_ROOT . '/core/includes/errors.inc';

  try {
    // Log the message to the watchdog and return an error page to the user.
    _drupal_log_error(_logs_http_decode_exception($exception), TRUE);
  }
  catch (Exception $exception2) {
    // Another uncaught exception was thrown while handling the first one.
    // If we are displaying errors, then do so with no possibility of a further uncaught exception being thrown.
    if (error_displayable()) {
      print '<h1>Additional uncaught exception thrown while handling exception.</h1>';
      print '<h2>Original</h2><p>' . Error::renderExceptionSafe($exception) . '</p>';
      print '<h2>Additional</h2><p>' . Error::renderExceptionSafe($exception2) . '</p><hr />';
    }
  }
}

/**
 * Decodes an exception and retrieves the correct caller.
 *
 * @param $exception
 *   The exception object that was thrown.
 *
 * @return array
 *   An error in the format expected by _drupal_log_error().
 *
 * @see _drupal_decode_exception()
 */
function _logs_http_decode_exception($exception) {
  $return = Error::decodeException($exception);

  // We have to serialize and encode the array here to prevent a notice in
  // theme_dblog_message(). We will decode the string back in
  // logs_http_watchdog()
  $return['exception_trace'] = Crypt::hashBase64(serialize($exception->getTrace()));

  return $return;
}

/**
 * Runs on shutdown to clean up and display developer information.
 *
 * devel_boot() registers this function as a shutdown function.
 */
function logs_http_shutdown() {
  if (!$events = logs_http_get_registered_events()) {
    return;
  }

  $url = logs_http_get_http_url();

  // Send events to logs.
  foreach ($events as $event) {
    $options = array(
      'method' => 'POST',
      'data' => Json::encode($event),
    );

    // Send data to Logs.
    $response = drupal_http_request($url, $options);
  }
}

/**
 * Get the registered events from the static cache.
 *
 * @return array
 *   Array of events.
 */
function logs_http_get_registered_events() {
  $events = &drupal_static('logs_http_events', array());
  return $events;
}

/**
 * Return the endpoint URL to POST data to.
 *
 * @return string
 *   Return the URL if exists, or NULL if disabled.
 */
function logs_http_get_http_url() {
  $config = \Drupal::configFactory()->getEditable('logs_http.settings');
  if (!$config->get('enabled') || !$config->get('url')) {
    // Don't register the event.
    return NULL;
  }

  return $config->get('url');
}

/**
 * Deep array filter.
 *
 * Remove empty values.
 *
 * @param $haystack
 *   The variable to filter.
 *
 * @return mixed
 */
function logs_http_array_remove_empty($haystack) {
  foreach ($haystack as $key => $value) {
    if (is_array($value)) {
      $haystack[$key] = logs_http_array_remove_empty($haystack[$key]);
    }

    if (empty($haystack[$key])) {
      unset($haystack[$key]);
    }
  }

  return $haystack;
}

